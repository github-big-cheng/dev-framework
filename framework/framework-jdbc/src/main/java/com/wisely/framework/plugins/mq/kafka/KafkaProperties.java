package com.wisely.framework.plugins.mq.kafka;

import lombok.Getter;
import lombok.Setter;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.boot.context.properties.PropertyMapper;
import org.springframework.util.unit.DataSize;

import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

@Setter
@Getter
public class KafkaProperties extends org.springframework.boot.autoconfigure.kafka.KafkaProperties {

    /**
     * 是否启用
     */
    private Boolean enabled;

//    spring.kafka.producer.retries=0
//            # 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)
//    spring.kafka.producer.acks=1
//            # 批量大小
//    spring.kafka.producer.batch-size=16384
//            # 生产端缓冲区大小
//    spring.kafka.producer.buffer-memory=33554432
//    spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
//    spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer

    @Setter
    @Getter
    public static class Producer {

        private final Ssl ssl = new Ssl();

        private final Security security = new Security();

        /**
         * Number of acknowledgments the producer requires the leader to have received
         * before considering a request complete.
         */
        private String acks = "1";

        /**
         * Default batch size. A small batch size will make batching less common and may
         * reduce throughput (a batch size of zero disables batching entirely).
         */
        private DataSize batchSize = DataSize.ofBytes(16384);

        /**
         * Comma-delimited list of host:port pairs to use for establishing the initial
         * connections to the Kafka cluster. Overrides the global property, for producers.
         */
        private List<String> bootstrapServers;

        /**
         * Total memory size the producer can use to buffer records waiting to be sent to
         * the server.
         */
        private DataSize bufferMemory = DataSize.ofBytes(33554432);

        /**
         * ID to pass to the server when making requests. Used for server-side logging.
         */
        private String clientId;

        /**
         * Compression type for all data generated by the producer.
         */
        private String compressionType;

        /**
         * Serializer class for keys.
         */
        private Class<?> keySerializer = StringSerializer.class;

        /**
         * Serializer class for values.
         */
        private Class<?> valueSerializer = StringSerializer.class;

        /**
         * When greater than zero, enables retrying of failed sends.
         */
        private Integer retries = 0;

        /**
         * When non empty, enables transaction support for producer.
         */
        private String transactionIdPrefix;

        /**
         * Additional producer-specific properties used to configure the client.
         */
        private final Map<String, String> properties = new HashMap<>();

        public Map<String, String> getProperties() {
            return this.properties;
        }

        public Map<String, Object> buildProperties() {
            Properties properties = new Properties();
            PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
            map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG));
            map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG));
            map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG));
            map.from(this::getBufferMemory).as(DataSize::toBytes)
                    .to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG));
            map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG));
            map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG));
            map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG));
            map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG));
            map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG));
            return properties.with(this.ssl, this.security, this.properties);
        }
    }

//    spring.kafka.bootstrap-servers=47.93.42.175:8053
//    spring.kafka.consumer.group-id=default
//    spring.kafka.consumer.enable-auto-commit=true
//    spring.kafka.consumer.auto-commit-interval=100
//    spring.kafka.consumer.auto-offset-reset=latest
//    spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
//    spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

    @Setter
    @Getter
    public static class Consumer {

        private final Ssl ssl = new Ssl();

        private final Security security = new Security();

        /**
         * Frequency with which the consumer offsets are auto-committed to Kafka if
         * 'enable.auto.commit' is set to true.
         */
        private Duration autoCommitInterval = Duration.ofSeconds(5);

        /**
         * What to do when there is no initial offset in Kafka or if the current offset no
         * longer exists on the server.
         */
        private String autoOffsetReset = "lastest";

        /**
         * Comma-delimited list of host:port pairs to use for establishing the initial
         * connections to the Kafka cluster. Overrides the global property, for consumers.
         */
        private List<String> bootstrapServers;

        /**
         * ID to pass to the server when making requests. Used for server-side logging.
         */
        private String clientId;

        /**
         * Whether the consumer's offset is periodically committed in the background.
         */
        private Boolean enableAutoCommit = true;

        /**
         * Maximum amount of time the server blocks before answering the fetch request if
         * there isn't sufficient data to immediately satisfy the requirement given by
         * "fetch-min-size".
         */
        private Duration fetchMaxWait;

        /**
         * Minimum amount of data the server should return for a fetch request.
         */
        private DataSize fetchMinSize;

        /**
         * Unique string that identifies the consumer group to which this consumer
         * belongs.
         */
        private String groupId;

        /**
         * Expected time between heartbeats to the consumer coordinator.
         */
        private Duration heartbeatInterval;

        /**
         * Isolation level for reading messages that have been written transactionally.
         */
        private IsolationLevel isolationLevel = IsolationLevel.READ_UNCOMMITTED;

        /**
         * Deserializer class for keys.
         */
        private Class<?> keyDeserializer = StringDeserializer.class;

        /**
         * Deserializer class for values.
         */
        private Class<?> valueDeserializer = StringDeserializer.class;

        /**
         * Maximum number of records returned in a single call to poll().
         */
        private Integer maxPollRecords;

        /**
         * Additional consumer-specific properties used to configure the client.
         */
        private final Map<String, String> properties = new HashMap<>();

        public Map<String, Object> buildProperties() {
            Properties properties = new Properties();
            PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
            map.from(this::getAutoCommitInterval).asInt(Duration::toMillis)
                    .to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG));
            map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG));
            map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));
            map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG));
            map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG));
            map.from(this::getFetchMaxWait).asInt(Duration::toMillis)
                    .to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG));
            map.from(this::getFetchMinSize).asInt(DataSize::toBytes)
                    .to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG));
            map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG));
            map.from(this::getHeartbeatInterval).asInt(Duration::toMillis)
                    .to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG));
            map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT))
                    .to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG));
            map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG));
            map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG));
            map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG));
            return properties.with(this.ssl, this.security, this.properties);
        }

    }


    protected static class Properties extends HashMap<String, Object> {

        <V> java.util.function.Consumer<V> in(String key) {
            return (value) -> put(key, value);
        }

        Properties with(Ssl ssl, Security security, Map<String, String> properties) {
            putAll(ssl.buildProperties());
            putAll(security.buildProperties());
            putAll(properties);
            return this;
        }

    }
}
